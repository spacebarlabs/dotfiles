#!/bin/bash

# Configuration
WATCH_DIR="$HOME/Magic/Add-Date"
LOG_DIR="$HOME/Magic/Log"
LOG_FILE="$LOG_DIR/Add-Date.log"

# Ensure directories exist
mkdir -p "$WATCH_DIR"
mkdir -p "$LOG_DIR"

# Logging Function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

log "Service started. Watching: $WATCH_DIR"

# Monitor the directory
# -e close_write: Triggers after a file is finished saving
# -e moved_to: Triggers when you drag and drop a file into the folder
inotifywait -m -e close_write -e moved_to --format "%f" "$WATCH_DIR" | while read FILENAME
do
    FULL_PATH="$WATCH_DIR/$FILENAME"

    # Safety check: Ensure file still exists
    if [ ! -f "$FULL_PATH" ]; then continue; fi

    # Regex for ISO8601 (YYYY-MM-DD)
    ISO_REGEX="([0-9]{4})-([0-9]{2})-([0-9]{2})"

    # ---------------------------------------------------------
    # CONDITION 1: Check if date is already at the beginning
    # ---------------------------------------------------------
    # We check for Date + Space (e.g., "2026-01-30 File.pdf")
    if [[ "$FILENAME" =~ ^$ISO_REGEX\  ]]; then
        # We don't log this to avoid spamming the log file
        continue
    fi

    DETECTED_DATE=""
    CLEAN_NAME="$FILENAME"
    SOURCE="None"

    # ---------------------------------------------------------
    # CONDITION 2: Check if date is elsewhere in the filename
    # ---------------------------------------------------------
    if [[ "$FILENAME" =~ $ISO_REGEX ]]; then
        DETECTED_DATE="${BASH_REMATCH[0]}"
        SOURCE="Filename"

        # Remove the date from the name so we don't have it twice
        # We also use 'tr -s' to squash any double spaces created by the removal
        CLEAN_NAME=$(echo "$FILENAME" | sed "s/$DETECTED_DATE//" | tr -s ' ' | sed 's/^[ -]*//')
    fi

    # ---------------------------------------------------------
    # CONDITION 3: Look inside the file (PDF/Metadata priority)
    # ---------------------------------------------------------
    if [ -z "$DETECTED_DATE" ]; then
        # Check CreateDate (PDFs/Docs) then DateTimeOriginal (Photos)
        META_DATE=$(exiftool -T -d "%Y-%m-%d" -CreateDate -CreationDate -DateCreated -DateTimeOriginal "$FULL_PATH" 2>/dev/null | awk '{print $1}')

        # Check if we got a valid date pattern back
        if [[ "$META_DATE" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            DETECTED_DATE="$META_DATE"
            SOURCE="Metadata"
        fi
    fi

    # ---------------------------------------------------------
    # CONDITION 4: Fallback to Today's Date
    # ---------------------------------------------------------
    if [ -z "$DETECTED_DATE" ]; then
        DETECTED_DATE=$(date +%Y-%m-%d)
        SOURCE="Today (Fallback)"
    fi

    # ---------------------------------------------------------
    # EXECUTE RENAME
    # ---------------------------------------------------------
    NEW_NAME="${DETECTED_DATE} ${CLEAN_NAME}"

    # Check if the new filename is actually different
    if [ "$FILENAME" != "$NEW_NAME" ]; then
        mv -n "$FULL_PATH" "$WATCH_DIR/$NEW_NAME"
        log "Processed: '$FILENAME' -> '$NEW_NAME' (Source: $SOURCE)"
    fi

done
